Access Modifiers
- public, private, protected, internal, protected internal
- Public
	- Accessible from everywhere.
- Private
	- Accessible only from the class it is implemented in.
- Protected
	- Accessible only from the class and its derived classes.
	- Breaks encapsulation. Avoid if you can.
- Internal
	- Accessible only from the same assembly.
- Protected Internal
	- Accessible only from the same assembly or any derived class.
	- Unlikely that we would ever need this

Constructors and Inheritance
- Base class constructors are always executed first.
- Base class constructors are not inherited.
- Example:
	public class Vehicle
	{
		private string _registrationNumber;

		public Vehicle(string registrationNumber)
		{
			_registrationNumber = registrationNumber;
		}
	}

	public class Car : Vehicle
	{
		public Car(string registrationNumber)
		{
			// Cannot set the registration number in the base class from here
			_registrationNumber = registrationNumber; // this is not valid
		}
	}

	- Instead, use the base keyword:
	public class Car : Vehicle
	{
		public Car(string registrationNumber)
			: base(registrationNumber)
		{
			// Initialize fields specific to the car class here
		}
	}

Updcasting and Downcasting
- Conversion from a derived class to a base class (upcasting)
- Conversion from a base calss tro a derived class (Downcasting)
- The 'as' and 'is' keywords
	
	public class Shape
	{
	}

	public class Circle : Shape
	{
	}

	Upcasting:
	Circle circle = new Circle();
	Shape shape = circle;

	Downcasting:
	Circle anotherCircle = (Circle)shape;

	Car car = (Car)shape; // throws InvalidCastException

	The as keyword:
	Car car = (Car) obj; // Explicit cast, may get exception

	Car car = obj as Car;  // No exception, but may be null
	if (car != null)
	{
	}

	The is keyword:
	if (obj is Car) // check the type of an object
	{
		Car car = (Car) obj;
	}
	
	Takeaways:
	In C#, upcasting is implicit so yo ucan convert an object reference to its base class reference. 
	In practical terms, wherever a method requires an object of a given type we can pass an object of that type or any types that derives from that type.

	In situations like handling a click of a button or anywhere where you get an argument and that argument has a limited view to that object, you can use 
	downcasting to convert that object to a more specific type. To do that you can use an explicit cast or the as keyword.

Boxing/Unboxing
- Value and Reference Types
- Boxing and Unboxing

- Types in C#
	- Value types
		- stored on the stack (limited amount of space in memory is allocated to each thread of your program)
			- Have a short lifetime, when out of scope, they are removed from the stack
		- Examples:
			- All primitive types: byte, int, float, char, bool
			- The struct type
	- Reference types
		- stored in the heap (larger amount of memory)
			- Store objects that require a longer lifetime
		- Examples:
			- Any classes (Object, Array, String, DbMigrator, etc.)


- Earlier in this section..
	- An object reference can be implicitly converted to a base class reference
		Circle circle = new Circle();
		Shape shape = circle;
	- Object class is the base of all classes in the .NET framework
		Circle circle = new Circle();
		Shape shape = circle;
		object shape = circle;

- Boxing
	- The process of converting a value type instance to an object reference
	- Example:
		int number = 10;
		object obj = number;
		// or
		object obj = 10;
		// ^^ what happens at runtime is that the value 10 gets "boxed" by the CLR and stored in the heap instead of the stack, then creates a reference on the stack.

- Unboxing
	- Example: 
		object obj = 10; // boxing already happened here
		int number = (int)obj; // new variable on the stack called number with a value of 10

- Boxing/Unboxing
	- Have a performance penalty.
	- Avoid if possible.